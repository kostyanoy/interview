# Тестовое задание "Инженер по отказоустойчивости"
## Улучшение времени запроса
1. Нам дан запрос:
```
explain analyze verbose
SELECT body 
  FROM posts 
 WHERE body ILIKE '%postgres%awesome%'
    OR body ILIKE '%postgres%amazing%';
```

План запроса:
```
Gather  (cost=1000.00..29342.86 rows=44 width=838) (actual time=138.563..2708.684 rows=40 loops=1)
  Output: body
  Workers Planned: 2
  Workers Launched: 2
  ->  Parallel Seq Scan on public.posts  (cost=0.00..28338.46 rows=18 width=838) (actual time=229.922..2701.880 rows=13 loops=3)
        Output: body
        Filter: ((posts.body ~~* '%postgres%awesome%'::text) OR (posts.body ~~* '%postgres%amazing%'::text))
        Rows Removed by Filter: 73451
        Worker 0:  actual time=225.221..2700.177 rows=12 loops=1
        Worker 1:  actual time=326.403..2700.328 rows=9 loops=1
Planning Time: 1.559 ms
Execution Time: 2708.718 ms
```
2. Проанализируем запрос

- Ищутся строки соответвующие шаблону `%postgres%awesome%` или `%postgres%amazing%`, т.е. содержат в себе ключевые слова, причем подстановочные символы идут в начале, середине и конце строк. 
- Поиск происходит по одной колонке 
- Запрос выполняется около 3 секунд
- В связи с текстовым поиском происходит последовательное сканирование (`Seq Scan`) строк с проверкой соответствия шаблонам

Вывод: на колонку `body` можно создать индекс

3. Выбор индекса

Для начала стоит определиться с типом индекса:
- B-tree - подходит для операции сравнения 
- Hash - подходит для операций равенства
- Gin - подходит для операции проверки наличия элементов в массиве/последовательности, текстовом поиске

В соответствие с документацией Postgres: индексы GIN являются предпочтительным типом индексов текстового поиска. Таким образом, остановимся на нем.

4. Создание индекса

Добавим расширение для поддержки триграмм (тройки символов), на которые разбивается текст для эффективного поиска по тексту.
```
CREATE EXTENSION pg_trgm;
```

В том числе расширение содержит оператор gin_trgm_ops для создания GIN индекса по триграммам. Таким образом, индекс заменяет необходимость анализа каждой строки на проверку мест, где потенциально может встретиться нужное слово.
```
CREATE INDEX ON posts USING gin(body gin_trgm_ops);
```

Такой индекс идеально подходит для нашего запроса, потому что происходит поиск ключевых слов с использованием ILIKE, что хорошо работает с Gin индексом.

5. Анализ работы запроса

Посмотрим теперь как будет выполняться запрос
```
explain analyze verbose
SELECT body 
  FROM posts 
 WHERE body ILIKE '%postgres%awesome%'
    OR body ILIKE '%postgres%amazing%';
```

План запроса
```
Bitmap Heap Scan on public.posts  (cost=296.35..467.68 rows=44 width=838) (actual time=6.750..10.523 rows=40 loops=1)
  Output: body
  Recheck Cond: ((posts.body ~~* '%postgres%awesome%'::text) OR (posts.body ~~* '%postgres%amazing%'::text))
  Rows Removed by Index Recheck: 20
  Heap Blocks: exact=59
  ->  BitmapOr  (cost=296.35..296.35 rows=44 width=0) (actual time=6.634..6.635 rows=0 loops=1)
        ->  Bitmap Index Scan on posts_body_idx  (cost=0.00..148.17 rows=22 width=0) (actual time=3.398..3.398 rows=36 loops=1)
              Index Cond: (posts.body ~~* '%postgres%awesome%'::text)
        ->  Bitmap Index Scan on posts_body_idx  (cost=0.00..148.17 rows=22 width=0) (actual time=3.235..3.235 rows=24 loops=1)
              Index Cond: (posts.body ~~* '%postgres%amazing%'::text)
Planning Time: 1.513 ms
Execution Time: 10.552 ms
```

Запрос выполнился за 10 мс. Как видно теперь вместо последовательного сканирования использовался `Bitmap Index Scan`, 
что является характерной чертой работы Gin индекса (он только так и может).

6. Анализ влияния индекса

Даже при создании индекса видно, что на его поддержку будут уходить дополнительные ресурсы, потому что его создание заняло около 1 минуты.

Индексы не всегда являются положительным фактором, потому что их нужно поддерживать при вставке и удалении данных, что приводит к дополнительным затратам. 
Если говорить про Gin индекс, то это касается его в особенной степени в силу того как он устроен: 
зачастую он содержит несколько вхождений для одной строки, поэтому обновление строки может затронуть изменение десятков или сотен вхождений в индекс.

Тем не менее мы всегда делаем выбор между скоростью отдельных выполнения запросов и дополнительными издержками для всех остальных. 

## Вопросы

### Представим себе, что данная БД находится под нагрузкой в продуктивном окружении. Если вам потребуется создать индекс, то как вы будете это делать?
Создание индекса блокирует таблицу на запись, и поскольку создание индекса может занимать продолжительное время, то таблица попросту будет недоступна. 
В условиях нагрузки это критически плохо.

1. Опция `CONCURRENTLY`
```
CREATE INDEX CONCURRENTLY ON posts using gin(body gin_trgm_ops);
```
Эта опция позволяет избежать блокировок при создании индекса. Естественно, не без минусов:
- Может выполняться гораздо дольше, особенно при высокой нагрузке (у меня заняло 1 min 12 sec)
- Требует больше вычислительных мощностей
2. В случае с индексом Gin можно подключить параметр `fastupdate`
```
CREATE INDEX CONCURRENTLY ON posts USING gin(body gin_trgm_ops) WITH (fastupdate = true);
```
При включенном параметре изменения будут накапливаться в буферной таблице в виде неупорядоченного списка. После все изменения одним скопом внесутся в индекс. Это позволит не дергать обновление индекса каждый раз, когда в таблицу вносятся изменения.

3. Запланировать создание индекса во время низкой активности, например, ночью.

### Является ли хорошей практикой создание индекса во время высокой транзакционной нагрузки?
Нет, чем меньше нагрузка во время создания индекса, тем меньше будет время создания и помех:
- Блокировка таблиц
- Увеличение нагрузки на систему и замедление работы остальных операций

### Какие параметры PostgreSQL нужно изменить, чтобы ускорить создание индекса при повышенной нагрузке?
- Увеличение `maintenance_work_mem` - этот параметр отвечает за память под "maintenance operations" - создание индексов, VACUUM...
- Увеличение `work_mem` - параметр отвечает за память под сортировку значений и хэш-таблицы, что естественно может понадобиться для создания различных индексов
- Увеличение `max_parallel_maintenance_workers` - параметр отвечает за максимальное количество параллельных рабочих процессов для "maintenance operations"
- Калибровка `maintenance_io_concurrency` - параметр отвечает количество одновременных дисковых операций ввода-вывода для "maintenance operations". НО споит брать в расчет железо, потому что для обычных HDD значение выше их количества будет только зря нагружать систему, а вот SSD может спокойно поддерживать насколько одновременных операций.  




